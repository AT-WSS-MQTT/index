<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>MQTT â†” WSS ç½‘å…³å®¢æˆ·ç«¯</title>
  <script src="./paho-mqtt-min.js"></script>
  <style>
    body { font-family: sans-serif; background: #f4f4f4; padding: 10px; }
    textarea {
      font-family: monospace;
      white-space: pre-wrap;
      word-break: break-word;
      max-width: 100%;
      width: 100%;
      box-sizing: border-box;
      resize: vertical;
    }
    .block { border: 1px solid #ccc; background: #fff; padding: 10px; margin-top: 10px; }
    .wss-title {
      font-weight: bold;
      margin-bottom: 6px;
      word-break: break-all;
    }
    .theme-area {
      font-size: 14px;
      margin-bottom: 6px;
      line-height: 1.5;
    }
    code {
      background: #eee;
      padding: 2px 4px;
      border-radius: 4px;
    }
    .notice {
      font-size: 15px;
      background: #fff7e6;
      padding: 10px;
      border: 1px solid #ffd591;
      margin-bottom: 15px;
    }
    h2 {
        margin-top: 10px;
        margin-bottom: 10px;
    }
  </style>
</head>
<body>
  <h2>MQTT â†” WSS ç½‘å…³å®¢æˆ·ç«¯</h2>

  <div class="notice">
    ğŸ“¡ <strong>æ¥æ”¶ WSS è¿æ¥çš„ MQTT ä¸»é¢˜ï¼š</strong> <code>client/ws_url/&lt;clientId&gt;</code><br>
    <strong>å‘å¸ƒæ ¼å¼ç¤ºä¾‹ï¼š</strong><br>
    <code>{"url":"wss://example.com/socket?instance=yz082m-smzsbh4lguauy53m-o735cjzyaeasv4o6"}</code><br>
    <hr>
    ğŸ”Œ <strong>ä¸»åŠ¨å…³é—­ WSS è¿æ¥çš„ç»Ÿä¸€ä¸»é¢˜ï¼š</strong> <code>client/disconnect/&lt;clientId&gt;</code><br>
    <strong>æ¶ˆæ¯ä½“ç¤ºä¾‹ï¼š</strong><br>
    <code>{"url":"smzsbh4lguauy53m-o735cjzyaeasv4o6"}</code><br>
    å‘é€åˆ°è¯¥ä¸»é¢˜åï¼Œå®¢æˆ·ç«¯ä¼šæŸ¥æ‰¾å¯¹åº”è¿æ¥å¹¶å…³é—­ã€‚
  </div>

  <div class="block">
    <div><strong>ğŸ†” å½“å‰å®¢æˆ·ç«¯ IDï¼š</strong> <code id="clientIdDisplay">åŠ è½½ä¸­...</code></div>
  </div>

  <div class="block">
    <div><strong>ğŸ“œ MQTT æ¶ˆæ¯æ—¥å¿—</strong></div>
    <textarea id="mqttLog" rows="10" readonly></textarea><br>
    <button onclick="document.getElementById('mqttLog').value = ''">ğŸª‘ æ¸…ç©ºæ—¥å¿—</button>
  </div>

  <div>
    <label>å‘å¸ƒä¸»é¢˜ï¼š</label>
    <input type="text" id="pubTopic" value="client/ws_url/<clientId>" size="40"><br><br>
    <label>å‘å¸ƒå†…å®¹ï¼š</label><br>
    <textarea id="pubMsg" rows="3">{"url":"wss://example.com/socket?instance=yz082m-smzsbh4lguauy53m-o735cjzyaeasv4o6"}</textarea><br>
    <button id="sendMqtt">å‘å¸ƒåˆ° MQTT</button>
  </div>

  <hr>
  <h3>è¿æ¥æ•°: <span id="connectionCount">0</span></h3>
  <div id="logContainer"></div>

  <script>
    const logContainer = document.getElementById('logContainer');
    const connectionCountElem = document.getElementById('connectionCount');
    const mqttLog = document.getElementById('mqttLog');
    let clientId = null;
    const wsMap = {};
    let mqttClient = null;
    const reconnectInterval = 3000;

    async function fetchClientIdUntilSuccess() {
      const url = 'http://127.0.0.1:3000/api/getClientId';

      return new Promise((resolve) => {
        const tryFetch = async () => {
          try {
            const res = await fetch(url);
            if (res.ok) {
              const data = await res.json();
              if (data.clientId) {
                logMqtt(`âœ… æˆåŠŸè·å– clientId: ${data.clientId}`);
                return resolve(data.clientId);
              } else {
                throw new Error("è¿”å›ä¸­æ—  clientId å­—æ®µ");
              }
            } else {
              throw new Error(`HTTP çŠ¶æ€ç : ${res.status}`);
            }
          } catch (e) {
            const errMsg = `âŒ è·å– clientId å¤±è´¥ï¼Œ3ç§’åé‡è¯•: ${e.message}`;
            console.warn(errMsg);
            logMqtt(errMsg);
            setTimeout(tryFetch, 3000);
          }
        };

        tryFetch();
      });
    }

    function updateConnectionCount() {
      connectionCountElem.innerText = Object.keys(wsMap).length;
    }

    function logTo(wssUrl, msg) {
      const entry = wsMap[wssUrl];
      if (entry) {
        entry.textarea.value += msg + "\n";
        entry.textarea.scrollTop = entry.textarea.scrollHeight;
      }
    }

    function logMqtt(msg) {
      mqttLog.value += msg + "\n";
      mqttLog.scrollTop = mqttLog.scrollHeight;
    }

    function getMqttTopicFromWssUrl(url) {
      try {
        const instance = new URL(url).searchParams.get("instance");
        return instance?.split("-").slice(1).join("-") || null;
      } catch {
        return null;
      }
    }

    function createWssLogBlock(wssUrl, mqttTopic, sendTopic, closeTopic) {
      const wrapper = document.createElement('div');
      wrapper.className = "block";

      const title = document.createElement('div');
      title.className = "wss-title";
      title.innerText = `ğŸ”— WSSè¿æ¥: ${wssUrl}`;

      const themeInfo = document.createElement('div');
      themeInfo.className = "theme-area";
      themeInfo.innerHTML = `
        <strong>ğŸ“› MQTT ä¸»é¢˜ï¼š</strong><br>
        âœ… æ¥æ”¶ä¸»é¢˜: <code>${mqttTopic}</code><br>
        ğŸ“¤ å‘é€ä¸»é¢˜: <code>${sendTopic}</code><br>
        âŒ çŠ¶æ€ä¸ŠæŠ¥: <code>${closeTopic}</code>
      `;

      const textarea = document.createElement('textarea');
      textarea.rows = 10;
      textarea.readOnly = true;

      wrapper.appendChild(title);
      wrapper.appendChild(themeInfo);
      wrapper.appendChild(textarea);
      logContainer.appendChild(wrapper);

      return { wrapper, textarea };
    }

    function connectWSS(wssUrl) {
      if (wsMap[wssUrl]) return logTo(wssUrl, "âš ï¸ å·²è¿æ¥ï¼Œæ— éœ€é‡å¤è¿æ¥");

      const mqttTopic = getMqttTopicFromWssUrl(wssUrl) || "client/ws_data";
      const sendTopic = mqttTopic + "/send";
      const closeTopic = mqttTopic + "/ws_close";
      const ws = new WebSocket(wssUrl);
      const { wrapper, textarea } = createWssLogBlock(wssUrl, mqttTopic, sendTopic, closeTopic);
      wsMap[wssUrl] = { ws, textarea, wrapper, mqttTopic, sendTopic, closeTopic };
      logTo(wssUrl, "â³ æ­£åœ¨è¿æ¥...");

      ws.onopen = () => {
        logTo(wssUrl, "âœ… WebSocket å·²è¿æ¥");
        mqttClient?.subscribe(sendTopic);
        logTo(wssUrl, `âœ… å·²è®¢é˜…å‘é€ä¸»é¢˜: ${sendTopic}`);
        updateConnectionCount();
      };

      ws.onmessage = e => {
        logTo(wssUrl, "ğŸ“¥ æ”¶åˆ°: " + e.data);
        const msg = new Paho.Message(e.data);
        msg.destinationName = mqttTopic;
        mqttClient.send(msg);
      };

      ws.onerror = e => logTo(wssUrl, "âŒ WebSocket é”™è¯¯");

      ws.onclose = e => {
        logTo(wssUrl, "ğŸ”’ WebSocket è¿æ¥å…³é—­");
        const payload = JSON.stringify({ url: wssUrl, status: "closed", reason: e.reason || "closed" });
        const msg = new Paho.Message(payload);
        msg.destinationName = closeTopic;
        mqttClient.send(msg);
        logMqtt(`ğŸ“¤ [${closeTopic}] ${payload}`);
        logContainer.removeChild(wsMap[wssUrl].wrapper);
        delete wsMap[wssUrl];
        updateConnectionCount();
      };
    }

    function connectMQTT() {
      mqttClient = new Paho.Client("127.0.0.1", 8882, clientId);

      mqttClient.onConnectionLost = function (res) {
        logMqtt("âš ï¸ MQTT è¿æ¥ä¸¢å¤±ï¼Œå‡†å¤‡é‡è¿...");
        setTimeout(connectMQTT, reconnectInterval);
      };

      mqttClient.onMessageArrived = function (msg) {
        const topic = msg.destinationName;
        const payload = msg.payloadString;

        let isForwarded = Object.values(wsMap).some(w => topic === w.mqttTopic);
        if (!isForwarded) logMqtt(`ğŸ“¥ [${topic}] ${payload}`);

        if (topic === `client/ws_url/${clientId}`) {
          try {
            const json = JSON.parse(payload);
            if (json.url?.startsWith("ws")) connectWSS(json.url);
          } catch {}
        }

        if (topic === `client/disconnect/${clientId}`) {
          try {
            const json = JSON.parse(payload);
            const target = Object.entries(wsMap).find(([k, v]) => v.mqttTopic === json.url);
            if (target) {
              logTo(target[0], "ğŸ›‘ æ”¶åˆ°æ–­å¼€æŒ‡ä»¤ï¼Œæ­£åœ¨å…³é—­è¿æ¥...");
              target[1].ws.close(1000, "ä¸»åŠ¨æ–­å¼€");
            }
          } catch {}
        }

        for (const wssUrl in wsMap) {
          const { ws, sendTopic } = wsMap[wssUrl];
          if (topic === sendTopic && ws.readyState === WebSocket.OPEN) {
            ws.send(payload);
            logTo(wssUrl, `ğŸ“¤ ä» MQTT å‘é€åˆ° WSS: ${payload}`);
          }
        }
      };

      mqttClient.connect({
        userName: "MQTT@@##admin",
        password: "MQTT@@##admin",
        useSSL: false,
        onSuccess: () => {
          logMqtt("âœ… MQTT å·²è¿æ¥");
          mqttClient.subscribe(`client/ws_url/${clientId}`);
          mqttClient.subscribe(`client/disconnect/${clientId}`);
        },
        onFailure: e => {
          logMqtt("âŒ MQTT è¿æ¥å¤±è´¥: " + e.errorMessage);
          setTimeout(connectMQTT, reconnectInterval);
        }
      });
    }

    async function init() {
      clientId = await fetchClientIdUntilSuccess();
      document.getElementById("clientIdDisplay").innerText = clientId;
      document.getElementById("pubTopic").value = `client/ws_url/${clientId}`;
      connectMQTT();
    }

    document.getElementById("sendMqtt").onclick = function () {
      const topic = document.getElementById("pubTopic").value.trim();// + "/" + clientId;
      const msg = document.getElementById("pubMsg").value;
      if (!mqttClient?.isConnected()) return alert("MQTT æœªè¿æ¥");
      try {
        const message = new Paho.Message(msg);
        message.destinationName = topic;
        mqttClient.send(message);
        logMqtt(`ğŸ“¤ [${topic}] ${msg}`);
        //alert("ğŸ“¤ å‘å¸ƒæˆåŠŸ: " + topic);
      } catch (e) {
        //alert("âŒ å‘å¸ƒå¤±è´¥: " + e.message);
      }
    };

    init();
  </script>
</body>
</html>
